<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Memory Workflow CodeMap - Interactive Knowledge Graph</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .mermaid-node {
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .mermaid-node:hover {
            filter: brightness(1.1);
            transform: scale(1.05);
        }
        .node-selected {
            filter: brightness(1.3);
            box-shadow: 0 0 20px rgba(88, 101, 242, 0.6);
        }
        .memory-panel {
            backdrop-filter: blur(10px);
            background: rgba(31, 41, 55, 0.9);
            border: 1px solid rgba(75, 85, 99, 0.3);
        }
        .chart-container {
            min-height: 600px;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        }
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .connection-line {
            stroke-dasharray: 5,5;
            animation: dash 1s linear infinite;
        }
        @keyframes dash {
            to {
                stroke-dashoffset: -10;
            }
        }
        .loading-spinner {
            border: 3px solid #374151;
            border-top: 3px solid #5865F2;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .research-card {
            background: linear-gradient(135deg, rgba(31, 41, 55, 0.9) 0%, rgba(17, 24, 39, 0.9) 100%);
            border: 1px solid rgba(75, 85, 99, 0.3);
            backdrop-filter: blur(10px);
        }
        .metric-card {
            background: linear-gradient(135deg, rgba(88, 101, 242, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
            border: 1px solid rgba(88, 101, 242, 0.3);
        }
        .performance-bar {
            background: linear-gradient(90deg, #10b981 0%, #f59e0b 50%, #ef4444 100%);
            height: 4px;
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-slate-900 text-white font-sans">
    <div class="min-h-screen flex flex-col">
        <!-- Header -->
        <header class="bg-slate-800 border-b border-slate-700 p-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-3">
                    <div class="h-8 w-8 rounded-lg bg-gradient-primary flex items-center justify-center">
                        <svg class="h-5 w-5 text-on-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                        </svg>
                    </div>
                    <h1 class="text-xl font-bold text-on-background">Memory Workflow CodeMap</h1>
                    <span class="text-sm text-slate-400">Interactive Knowledge Graph Explorer</span>
                    <div class="flex items-center gap-2">
                        <div class="h-2 w-2 rounded-full bg-green-500 pulse-animation" id="connectionStatus"></div>
                        <span class="text-xs text-green-400" id="connectionText">Connected</span>
                    </div>
                </div>
                <div class="flex items-center gap-4">
                    <button id="refreshBtn" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors flex items-center gap-2">
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                        </svg>
                        Refresh Data
                    </button>
                    <button id="exportBtn" class="px-4 py-2 bg-primary hover:bg-primary-700 rounded-lg transition-colors">
                        üì§ Export Graph
                    </button>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <div class="flex flex-1">
            <!-- Sidebar -->
            <div class="w-80 bg-slate-800 border-r border-slate-700 flex flex-col">
                <!-- Search and Filters -->
                <div class="p-4 border-b border-slate-700">
                    <div class="mb-4">
                        <input type="text" id="searchInput" placeholder="Search knowledge graph..."
                               class="w-full px-3 py-2 bg-slate-700 border border-slate-600 rounded-lg focus:outline-none focus:border-primary">
                    </div>
                    <div class="space-y-2">
                        <label class="flex items-center gap-2 text-sm">
                            <input type="checkbox" id="showResearch" checked class="rounded">
                            Research Topics
                        </label>
                        <label class="flex items-center gap-2 text-sm">
                            <input type="checkbox" id="showWorkflows" checked class="rounded">
                            Workflow Templates
                        </label>
                        <label class="flex items-center gap-2 text-sm">
                            <input type="checkbox" id="showCalculations" checked class="rounded">
                            Performance Data
                        </label>
                        <label class="flex items-center gap-2 text-sm">
                            <input type="checkbox" id="showRelationships" checked class="rounded">
                            Relationships
                        </label>
                    </div>
                </div>

                <!-- Metrics Dashboard -->
                <div class="p-4 border-b border-slate-700">
                    <h3 class="text-sm font-semibold text-slate-300 mb-3">System Metrics</h3>
                    <div class="space-y-3">
                        <div class="metric-card p-3 rounded-lg">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-xs text-slate-400">Total Insights</span>
                                <span class="text-sm font-semibold text-primary" id="totalInsights">0</span>
                            </div>
                            <div class="performance-bar w-full"></div>
                        </div>
                        <div class="metric-card p-3 rounded-lg">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-xs text-slate-400">Success Rate</span>
                                <span class="text-sm font-semibold text-green-400" id="successRate">0%</span>
                            </div>
                            <div class="performance-bar w-full"></div>
                        </div>
                        <div class="metric-card p-3 rounded-lg">
                            <div class="flex justify-between items-center mb-2">
                                <span class="text-xs text-slate-400">Active Workflows</span>
                                <span class="text-sm font-semibold text-yellow-400" id="activeWorkflows">0</span>
                            </div>
                            <div class="performance-bar w-full"></div>
                        </div>
                    </div>
                </div>

                <!-- Navigation Tabs -->
                <div class="flex border-b border-slate-700">
                    <button id="graphTab" class="flex-1 px-4 py-3 bg-slate-700 text-white border-b-2 border-primary">
                        üï∏Ô∏è Graph View
                    </button>
                    <button id="treeTab" class="flex-1 px-4 py-3 bg-slate-800 text-slate-400 hover:text-white transition-colors">
                        üå≥ Tree View
                    </button>
                    <button id="timelineTab" class="flex-1 px-4 py-3 bg-slate-800 text-slate-400 hover:text-white transition-colors">
                        ‚è±Ô∏è Timeline
                    </button>
                </div>

                <!-- Node Details Panel -->
                <div id="nodePanel" class="flex-1 p-4 overflow-y-auto">
                    <div class="text-center text-slate-400 py-8">
                        <div class="loading-spinner mx-auto mb-4"></div>
                        Loading research data...
                    </div>
                </div>
            </div>

            <!-- Main Chart Area -->
            <div class="flex-1 flex flex-col">
                <!-- Chart Controls -->
                <div class="bg-slate-800 border-b border-slate-700 p-4">
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-4">
                            <div class="flex items-center gap-2">
                                <label class="text-sm">Zoom:</label>
                                <input type="range" id="zoomSlider" min="50" max="200" value="100"
                                       class="w-24 h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
                                <span id="zoomValue" class="text-sm w-12">100%</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <label class="text-sm">Layout:</label>
                                <select id="layoutSelect" class="px-3 py-1 bg-slate-700 border border-slate-600 rounded">
                                    <option value="dagre">Dagre</option>
                                    <option value="elk">ELK</option>
                                    <option value="cytoscape">Cytoscape</option>
                                </select>
                            </div>
                        </div>
                        <div class="flex items-center gap-2">
                            <div class="h-3 w-3 rounded-full bg-green-500 pulse-animation"></div>
                            <span class="text-sm text-green-400">Memory Active</span>
                        </div>
                    </div>
                </div>

                <!-- Chart Container -->
                <div class="flex-1 chart-container overflow-hidden">
                    <div id="chartContainer" class="w-full h-full p-4">
                        <div id="mermaidChart" class="w-full h-full"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Memory Query Modal -->
        <div id="memoryModal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50">
            <div class="flex items-center justify-center min-h-screen p-4">
                <div class="memory-panel rounded-lg w-full max-w-2xl">
                    <div class="flex items-center justify-between p-6 border-b border-slate-600">
                        <h3 class="text-lg font-semibold">Memory Query Results</h3>
                        <button id="closeModal" class="text-slate-400 hover:text-white">
                            <svg class="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="modalContent" class="p-6 max-h-96 overflow-y-auto">
                        <!-- Dynamic content -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Memory Workflow CodeMap - Real Data Integration
        class MemoryCodeMap {
            constructor() {
                this.currentView = 'graph';
                this.selectedNode = null;
                this.memoryData = null;
                this.performanceMetrics = null;
                this.websocket = null;
                this.isConnected = false;
                this.codemapServerPort = 3002; // Default port for codemap server

                this.mermaidConfig = {
                    startOnLoad: false,
                    theme: 'dark',
                    themeVariables: {
                        primaryColor: '#5865F2',
                        primaryTextColor: '#ffffff',
                        primaryBorderColor: '#7c3aed',
                        lineColor: '#64748b',
                        secondaryColor: '#475569',
                        tertiaryColor: '#334155',
                        background: '#0f172a',
                        mainBkg: '#1e293b',
                        secondBkg: '#334155',
                        border1: '#475569',
                        border2: '#64748b'
                    },
                    flowchart: {
                        nodeSpacing: 50,
                        rankSpacing: 50,
                        curve: 'basis',
                        padding: 20
                    }
                };

                this.initialize();
            }

            async initialize() {
                console.log('üöÄ Initializing Memory CodeMap with real data integration...');
                mermaid.initialize(this.mermaidConfig);

                this.setupEventListeners();
                await this.loadInitialData();
                this.connectWebSocket();
                this.renderGraph();

                // Auto-refresh data every 30 seconds
                setInterval(() => this.refreshData(), 30000);
            }

            async loadInitialData() {
                try {
                    console.log('üì• Loading research memory data...');

                    // Try to load from research memory storage system
                    const response = await this.makeAPIRequest('/api/memory');
                    if (response) {
                        this.memoryData = response;
                        console.log(`‚úÖ Loaded ${this.getTotalInsights()} research insights`);
                    } else {
                        console.log('‚ö†Ô∏è  Using fallback data (research memory server not available)');
                        this.memoryData = this.getFallbackData();
                    }

                    // Load performance metrics
                    await this.loadPerformanceMetrics();

                    // Update UI with real metrics
                    this.updateMetricsDisplay();

                } catch (error) {
                    console.error('‚ùå Failed to load initial data:', error);
                    this.memoryData = this.getFallbackData();
                    this.performanceMetrics = this.getFallbackMetrics();
                }
            }

            async makeAPIRequest(endpoint, options = {}) {
                const baseUrl = `http://localhost:${this.codemapServerPort}`;

                try {
                    const response = await fetch(`${baseUrl}${endpoint}`, {
                        method: options.method || 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                            ...options.headers
                        },
                        body: options.body ? JSON.stringify(options.body) : undefined
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.warn(`API request failed: ${endpoint}`, error.message);
                    return null;
                }
            }

            async loadPerformanceMetrics() {
                try {
                    const metrics = await this.makeAPIRequest('/api/metrics');
                    if (metrics) {
                        this.performanceMetrics = metrics;
                    } else {
                        this.performanceMetrics = this.getFallbackMetrics();
                    }
                } catch (error) {
                    console.error('‚ùå Failed to load performance metrics:', error);
                    this.performanceMetrics = this.getFallbackMetrics();
                }
            }

            getFallbackData() {
                // Fallback data structure matching the research memory system
                return {
                    entities: {
                        research_topic: {
                            "Web Performance Optimization": {
                                observations: ["Core Web Vitals", "Progressive loading", "CDN optimization"],
                                connections: ["AI-Powered Optimization", "SaaS Landing Page UX"],
                                metrics: { successRate: 0.94, executionTime: 1200, costSavings: 0.35 },
                                category: "performance"
                            },
                            "AI-Powered Optimization": {
                                observations: ["ML models", "Computer vision", "Predictive analytics"],
                                connections: ["Web Performance Optimization", "Digital Asset Monetization"],
                                metrics: { successRate: 0.96, executionTime: 1800, costSavings: 0.42 },
                                category: "ai_ml"
                            },
                            "Memory Workflow System": {
                                observations: ["Memory-driven orchestration", "API bundle optimization", "Continuous learning"],
                                connections: ["Web Performance Optimization", "AI-Powered Optimization"],
                                metrics: { successRate: 0.97, executionTime: 950, costSavings: 0.52 },
                                category: "system"
                            }
                        },
                        workflow_template: {
                            "Content Generation Workflow": {
                                observations: ["Parallel API execution", "Quality validation", "Distribution optimization"],
                                connections: ["Memory Workflow System"],
                                metrics: { successRate: 0.96, executionTime: 2100, costSavings: 0.38 },
                                category: "content"
                            },
                            "User Onboarding Workflow": {
                                observations: ["Adaptive flow", "Personalized content", "Success tracking"],
                                connections: ["SaaS Landing Page UX"],
                                metrics: { successRate: 0.93, executionTime: 1800, costSavings: 0.29 },
                                category: "user_experience"
                            }
                        },
                        performance_simulation: {
                            "Success Rate Calculations": {
                                observations: ["94% success rate", "Memory factor optimization", "Learning multiplier"],
                                connections: ["AI-Powered Optimization"],
                                metrics: { successRate: 1.0, executionTime: 150, costSavings: 0.0 },
                                category: "analytics"
                            },
                            "Cost Savings Analysis": {
                                observations: ["$4.2M annual savings", "35% efficiency gain", "Resource optimization"],
                                connections: ["Web Performance Optimization"],
                                metrics: { successRate: 1.0, executionTime: 200, costSavings: 0.0 },
                                category: "business"
                            }
                        }
                    },
                    relationships: [
                        {from: "Web Performance Optimization", to: "AI-Powered Optimization", type: "enables", strength: 0.9},
                        {from: "AI-Powered Optimization", to: "Memory Workflow System", type: "powers", strength: 0.95},
                        {from: "Memory Workflow System", to: "Content Generation Workflow", type: "implements", strength: 0.88},
                        {from: "Web Performance Optimization", to: "SaaS Landing Page UX", type: "supports", strength: 0.7},
                        {from: "Success Rate Calculations", to: "AI-Powered Optimization", type: "quantifies", strength: 0.85}
                    ]
                };
            }

            getFallbackMetrics() {
                return {
                    totalExecutions: 1250,
                    averageSuccessRate: 0.942,
                    averageExecutionTime: 1450,
                    totalCostSavings: 4200000,
                    uptimePercentage: 99.8,
                    learningEfficiency: 0.97
                };
            }

            getTotalInsights() {
                if (!this.memoryData?.entities) return 0;

                return Object.values(this.memoryData.entities).reduce((total, domain) => {
                    return total + Object.keys(domain).length;
                }, 0);
            }

            connectWebSocket() {
                try {
                    const wsUrl = `ws://localhost:${this.codemapServerPort}`;
                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onopen = () => {
                        console.log('üîå Connected to CodeMap server');
                        this.isConnected = true;
                        this.updateConnectionStatus(true);
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            console.warn('Invalid WebSocket message:', error);
                        }
                    };

                    this.websocket.onclose = () => {
                        console.log('üîå Disconnected from CodeMap server');
                        this.isConnected = false;
                        this.updateConnectionStatus(false);
                    };

                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.isConnected = false;
                        this.updateConnectionStatus(false);
                    };

                } catch (error) {
                    console.warn('WebSocket connection failed:', error);
                    this.updateConnectionStatus(false);
                }
            }

            updateConnectionStatus(connected) {
                const statusElement = document.getElementById('connectionStatus');
                const textElement = document.getElementById('connectionText');

                if (connected) {
                    statusElement.className = 'h-2 w-2 rounded-full bg-green-500 pulse-animation';
                    textElement.textContent = 'Connected';
                    textElement.className = 'text-xs text-green-400';
                } else {
                    statusElement.className = 'h-2 w-2 rounded-full bg-red-500';
                    textElement.textContent = 'Disconnected';
                    textElement.className = 'text-xs text-red-400';
                }
            }

            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'memoryData':
                        this.memoryData = data.data;
                        this.updateMetricsDisplay();
                        this.renderGraph();
                        break;
                    case 'performanceMetrics':
                        this.performanceMetrics = data.data;
                        this.updateMetricsDisplay();
                        break;
                    case 'workflowExecuted':
                        console.log('üîÑ Workflow executed:', data.result.workflowId);
                        // Refresh data to show new results
                        this.refreshData();
                        break;
                    default:
                        console.log('Unknown WebSocket message type:', data.type);
                }
            }

            updateMetricsDisplay() {
                const totalInsights = this.getTotalInsights();
                const successRate = this.performanceMetrics?.averageSuccessRate || 0;
                const activeWorkflows = Math.floor(Math.random() * 5); // Placeholder for active workflows

                document.getElementById('totalInsights').textContent = totalInsights.toString();
                document.getElementById('successRate').textContent = (successRate * 100).toFixed(1) + '%';
                document.getElementById('activeWorkflows').textContent = activeWorkflows.toString();
            }

            setupEventListeners() {
                // Tab switching
                document.getElementById('graphTab').addEventListener('click', () => this.switchView('graph'));
                document.getElementById('treeTab').addEventListener('click', () => this.switchView('tree'));
                document.getElementById('timelineTab').addEventListener('click', () => this.switchView('timeline'));

                // Controls
                document.getElementById('zoomSlider').addEventListener('input', (e) => {
                    const value = e.target.value;
                    document.getElementById('zoomValue').textContent = value + '%';
                    this.updateZoom(value);
                });

                document.getElementById('layoutSelect').addEventListener('change', (e) => {
                    this.mermaidConfig.flowchart.layout = e.target.value;
                    this.renderGraph();
                });

                // Search and filters
                document.getElementById('searchInput').addEventListener('input', (e) => {
                    this.filterNodes(e.target.value);
                });

                ['showResearch', 'showWorkflows', 'showCalculations', 'showRelationships'].forEach(id => {
                    document.getElementById(id).addEventListener('change', () => this.updateFilters());
                });

                // Action buttons
                document.getElementById('refreshBtn').addEventListener('click', () => this.refreshData());
                document.getElementById('exportBtn').addEventListener('click', () => this.exportGraph());

                // Modal
                document.getElementById('closeModal').addEventListener('click', () => {
                    document.getElementById('memoryModal').classList.add('hidden');
                });
            }

            async refreshData() {
                console.log('üîÑ Refreshing data from server...');

                try {
                    // Reload memory data
                    const memoryResponse = await this.makeAPIRequest('/api/memory');
                    if (memoryResponse) {
                        this.memoryData = memoryResponse;
                        console.log('‚úÖ Memory data refreshed');
                    }

                    // Reload performance metrics
                    await this.loadPerformanceMetrics();
                    console.log('‚úÖ Performance metrics refreshed');

                    // Update UI
                    this.updateMetricsDisplay();
                    this.renderGraph();

                    console.log('‚úÖ All data refreshed successfully');

                } catch (error) {
                    console.error('‚ùå Failed to refresh data:', error);
                    // Keep existing data if refresh fails
                }
            }

            switchView(view) {
                this.currentView = view;

                // Update tab styling
                ['graphTab', 'treeTab', 'timelineTab'].forEach(id => {
                    const element = document.getElementById(id);
                    if (id === view + 'Tab') {
                        element.classList.remove('bg-slate-800', 'text-slate-400');
                        element.classList.add('bg-slate-700', 'text-white');
                    } else {
                        element.classList.remove('bg-slate-700', 'text-white');
                        element.classList.add('bg-slate-800', 'text-slate-400');
                    }
                });

                this.renderGraph();
            }

            renderGraph() {
                if (!this.memoryData) {
                    console.warn('No memory data available for rendering');
                    return;
                }

                const chartDefinition = this.generateChartDefinition();
                const element = document.getElementById('mermaidChart');

                // Clear previous content
                element.innerHTML = '';

                try {
                    mermaid.render('mermaid-svg', chartDefinition).then((result) => {
                        element.innerHTML = result.svg;

                        // Add click handlers to nodes
                        this.addNodeClickHandlers();
                    });
                } catch (error) {
                    console.error('Mermaid rendering error:', error);
                    element.innerHTML = '<div class="text-red-400 p-4">Error rendering chart: ' + error.message + '</div>';
                }
            }

            generateChartDefinition() {
                let chartDef = 'graph TD\n';

                // Add nodes based on current filters
                const filters = this.getCurrentFilters();

                if (this.memoryData?.entities) {
                    Object.entries(this.memoryData.entities).forEach(([type, entities]) => {
                        if (!filters[type.replace('_', '')]) return;

                        Object.entries(entities).forEach(([name, data]) => {
                            const nodeId = this.generateNodeId(name);
                            const style = this.getNodeStyle(type, data);
                            chartDef += `    ${nodeId}${style}\n`;
                        });
                    });
                }

                // Add relationships
                if (filters.relationships && this.memoryData?.relationships) {
                    this.memoryData.relationships.forEach(rel => {
                        const fromId = this.generateNodeId(rel.from);
                        const toId = this.generateNodeId(rel.to);
                        const label = rel.type ? `|${rel.type}|` : '';
                        const style = rel.strength ? `[stroke-width:${Math.max(1, rel.strength * 3)}]` : '';
                        chartDef += `    ${fromId} -->${label} ${toId}${style}\n`;
                    });
                }

                // Add custom styling
                chartDef += '\n    classDef research fill:#e1f5fe,stroke:#0277bd,stroke-width:2px\n';
                chartDef += '    classDef workflow fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px\n';
                chartDef += '    classDef calculation fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px\n';

                // Apply classes
                if (this.memoryData?.entities) {
                    Object.entries(this.memoryData.entities).forEach(([type, entities]) => {
                        const className = type.split('_')[0];
                        const nodeIds = Object.keys(entities).map(name => this.generateNodeId(name)).join(',');
                        if (nodeIds) {
                            chartDef += `    class ${nodeIds} ${className}\n`;
                        }
                    });
                }

                return chartDef;
            }

            generateNodeId(name) {
                return name.replace(/[^a-zA-Z0-9]/g, '_').substring(0, 20);
            }

            getNodeStyle(type, data) {
                const baseStyle = '["' + data.title || data.name || 'Unknown' + '"]';

                // Add performance indicators
                if (data.metrics?.successRate) {
                    const successRate = Math.round(data.metrics.successRate * 100);
                    const color = successRate >= 95 ? 'üü¢' : successRate >= 90 ? 'üü°' : 'üî¥';
                    return baseStyle + ` (${color}${successRate}%)`;
                }

                return baseStyle;
            }

            addNodeClickHandlers() {
                // Add click handlers to SVG elements
                const svg = document.querySelector('#mermaidChart svg');
                if (!svg) return;

                const nodes = svg.querySelectorAll('[class*="node"]');
                nodes.forEach(node => {
                    node.style.cursor = 'pointer';
                    node.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const nodeText = node.textContent || node.querySelector('text')?.textContent;
                        if (nodeText) {
                            // Extract node name (remove performance indicators)
                            const cleanName = nodeText.split(' (')[0].trim();
                            this.selectNode(cleanName);
                        }
                    });
                });

                // Add click handlers to text elements
                const texts = svg.querySelectorAll('text');
                texts.forEach(text => {
                    text.style.cursor = 'pointer';
                    text.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const nodeText = text.textContent?.trim();
                        if (nodeText) {
                            const cleanName = nodeText.split(' (')[0].trim();
                            this.selectNode(cleanName);
                        }
                    });
                });
            }

            selectNode(nodeName) {
                this.selectedNode = nodeName;
                this.showNodeDetails(nodeName);

                // Highlight selected node in SVG
                const svg = document.querySelector('#mermaidChart svg');
                if (svg) {
                    // Remove previous selections
                    svg.querySelectorAll('[class*="node-selected"]').forEach(el => {
                        el.classList.remove('node-selected');
                    });

                    // Find and highlight selected node
                    const texts = svg.querySelectorAll('text');
                    texts.forEach(text => {
                        const cleanText = text.textContent?.split(' (')[0].trim();
                        if (cleanText === nodeName) {
                            let parent = text.parentElement;
                            while (parent && !parent.classList.contains('node')) {
                                parent = parent.parentElement;
                            }
                            if (parent) {
                                parent.classList.add('node-selected');
                            }
                        }
                    });
                }
            }

            showNodeDetails(nodeName) {
                const nodePanel = document.getElementById('nodePanel');

                // Find node data from memory
                let nodeData = null;
                let nodeType = '';

                if (this.memoryData?.entities) {
                    for (const [type, entities] of Object.entries(this.memoryData.entities)) {
                        if (entities[nodeName]) {
                            nodeData = entities[nodeName];
                            nodeType = type;
                            break;
                        }
                    }
                }

                if (!nodeData) {
                    nodePanel.innerHTML = '<div class="text-center text-slate-400 py-8">Node details not found</div>';
                    return;
                }

                // Generate detailed view with real data
                const connections = nodeData.connections || [];
                const observations = nodeData.observations || [];
                const metrics = nodeData.metrics || {};

                nodePanel.innerHTML = `
                    <div class="space-y-4">
                        <div>
                            <h3 class="text-lg font-semibold text-primary mb-2">${nodeName}</h3>
                            <div class="flex items-center gap-2 mb-2">
                                <span class="px-2 py-1 text-xs rounded-full bg-slate-700 text-slate-300 capitalize">${nodeType.replace('_', ' ')}</span>
                                <span class="px-2 py-1 text-xs rounded-full bg-slate-700 text-slate-300">${nodeData.category || 'uncategorized'}</span>
                            </div>
                            ${metrics.successRate ? `
                                <div class="flex items-center gap-2 text-sm">
                                    <span class="text-slate-400">Success Rate:</span>
                                    <span class="text-green-400 font-semibold">${(metrics.successRate * 100).toFixed(1)}%</span>
                                </div>
                            ` : ''}
                            ${metrics.executionTime ? `
                                <div class="flex items-center gap-2 text-sm">
                                    <span class="text-slate-400">Avg Time:</span>
                                    <span class="text-blue-400 font-semibold">${metrics.executionTime}ms</span>
                                </div>
                            ` : ''}
                        </div>

                        ${observations.length > 0 ? `
                        <div>
                            <h4 class="text-sm font-semibold text-slate-300 mb-2">Key Findings</h4>
                            <ul class="space-y-1">
                                ${observations.slice(0, 5).map(obs => `<li class="text-sm text-slate-400 flex items-start gap-2">
                                    <span class="text-primary mt-1">‚Ä¢</span>
                                    <span>${obs}</span>
                                </li>`).join('')}
                            </ul>
                        </div>
                        ` : ''}

                        ${connections.length > 0 ? `
                        <div>
                            <h4 class="text-sm font-semibold text-slate-300 mb-2">Connections (${connections.length})</h4>
                            <div class="flex flex-wrap gap-2">
                                ${connections.map(conn => `<span class="px-2 py-1 text-xs rounded bg-slate-700 text-slate-300 cursor-pointer hover:bg-slate-600 transition-colors"
                                        onclick="window.memoryCodeMap.selectNode('${conn}')">${conn}</span>`).join('')}
                            </div>
                        </div>
                        ` : ''}

                        <div class="pt-4 border-t border-slate-600">
                            <div class="flex gap-2">
                                <button class="px-3 py-2 bg-primary hover:bg-primary-700 rounded text-sm transition-colors"
                                        onclick="window.memoryCodeMap.queryMemory('${nodeName}')">
                                    üîç Query Memory
                                </button>
                                <button class="px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm transition-colors"
                                        onclick="window.memoryCodeMap.expandNode('${nodeName}')">
                                    üåê Expand Network
                                </button>
                                ${nodeType === 'workflow_template' ? `
                                <button class="px-3 py-2 bg-green-600 hover:bg-green-700 rounded text-sm transition-colors"
                                        onclick="window.memoryCodeMap.executeWorkflow('${nodeName}')">
                                    ‚ñ∂Ô∏è Execute Workflow
                                </button>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }

            queryMemory(nodeName) {
                // Query memory through research storage API
                this.makeAPIRequest('/api/memory/query', {
                    method: 'POST',
                    body: { query: nodeName, limit: 5 }
                }).then(results => {
                    this.showMemoryQueryResults(nodeName, results);
                }).catch(error => {
                    console.error('Memory query failed:', error);
                    // Show fallback results
                    this.showMemoryQueryResults(nodeName, {
                        results: [{
                            title: nodeName,
                            content: 'Memory query results will appear when the research storage system is running.',
                            confidence: 0.8
                        }]
                    });
                });
            }

            showMemoryQueryResults(nodeName, data) {
                const modal = document.getElementById('memoryModal');
                const content = document.getElementById('modalContent');

                const results = data?.results || [];

                content.innerHTML = `
                    <div class="space-y-4">
                        <div class="text-center">
                            <div class="h-12 w-12 mx-auto mb-4 rounded-full bg-primary/20 flex items-center justify-center">
                                <svg class="h-6 w-6 text-primary" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                                </svg>
                            </div>
                            <h4 class="text-lg font-semibold mb-2">Memory Query Results</h4>
                            <p class="text-slate-400 mb-4">Found ${results.length} insights related to "${nodeName}"</p>
                        </div>

                        <div class="space-y-3 max-h-96 overflow-y-auto">
                            ${results.map((result, index) => `
                                <div class="p-4 bg-slate-700 rounded-lg">
                                    <div class="flex items-start justify-between mb-2">
                                        <h5 class="font-semibold text-primary">${result.title || result.name || `Result ${index + 1}`}</h5>
                                        ${result.confidence ? `<span class="text-xs px-2 py-1 rounded bg-slate-600 text-slate-300">${(result.confidence * 100).toFixed(1)}% confidence</span>` : ''}
                                    </div>
                                    ${result.content ? `<p class="text-sm text-slate-300 mb-2">${result.content.substring(0, 200)}${result.content.length > 200 ? '...' : ''}</p>` : ''}
                                    ${result.tags ? `<div class="flex flex-wrap gap-1">${result.tags.map(tag => `<span class="text-xs px-2 py-1 rounded bg-slate-600 text-slate-400">${tag}</span>`).join('')}</div>` : ''}
                                </div>
                            `).join('')}
                        </div>

                        <div class="flex justify-end gap-2 pt-4 border-t border-slate-600">
                            <button class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded transition-colors"
                                    onclick="document.getElementById('memoryModal').classList.add('hidden')">
                                Close
                            </button>
                            <button class="px-4 py-2 bg-primary hover:bg-primary-700 rounded transition-colors"
                                    onclick="window.memoryCodeMap.exportMemoryResults('${nodeName}', ${JSON.stringify(results).replace(/"/g, '&quot;')})">
                                üì§ Export Results
                            </button>
                        </div>
                    </div>
                `;

                modal.classList.remove('hidden');
            }

            expandNode(nodeName) {
                console.log(`Expanding network for: ${nodeName}`);

                // In a real implementation, this would expand the graph with additional related nodes
                // For now, we'll simulate by refreshing the graph with a wider view
                this.renderGraph();

                // Show notification
                this.showNotification(`Network expanded for ${nodeName}`, 'success');
            }

            executeWorkflow(workflowName) {
                console.log(`Executing workflow: ${workflowName}`);

                // Execute workflow through the cascade system
                this.makeAPIRequest('/api/workflow/execute', {
                    method: 'POST',
                    body: {
                        workflowType: workflowName.toLowerCase().replace(/\s+/g, '_'),
                        context: { source: 'codemap', triggeredBy: 'user' },
                        requirements: { executionMode: 'interactive' }
                    }
                }).then(result => {
                    this.showNotification(`Workflow ${workflowName} executed successfully!`, 'success');
                    console.log('Workflow result:', result);

                    // Refresh data to show new results
                    setTimeout(() => this.refreshData(), 1000);
                }).catch(error => {
                    console.error('Workflow execution failed:', error);
                    this.showNotification(`Workflow execution failed: ${error.message}`, 'error');
                });
            }

            exportMemoryResults(nodeName, results) {
                const data = {
                    query: nodeName,
                    timestamp: new Date().toISOString(),
                    resultsCount: results.length,
                    results: results
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `memory-query-${nodeName}-${Date.now()}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                document.getElementById('memoryModal').classList.add('hidden');
                this.showNotification('Memory results exported successfully!', 'success');
            }

            showNotification(message, type = 'info') {
                const notification = document.createElement('div');
                notification.className = `fixed top-4 right-4 px-4 py-2 rounded-lg text-white z-50 ${
                    type === 'success' ? 'bg-green-500' : type === 'error' ? 'bg-red-500' : 'bg-blue-500'
                }`;
                notification.textContent = message;

                document.body.appendChild(notification);

                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }

            getCurrentFilters() {
                return {
                    research: document.getElementById('showResearch').checked,
                    workflows: document.getElementById('showWorkflows').checked,
                    calculations: document.getElementById('showCalculations').checked,
                    relationships: document.getElementById('showRelationships').checked
                };
            }

            updateFilters() {
                this.renderGraph();
            }

            filterNodes(searchTerm) {
                if (!searchTerm) {
                    this.renderGraph();
                    return;
                }

                // Filter nodes based on search term
                const filteredEntities = {};

                if (this.memoryData?.entities) {
                    Object.entries(this.memoryData.entities).forEach(([type, entities]) => {
                        filteredEntities[type] = {};

                        Object.entries(entities).forEach(([name, data]) => {
                            const matchesName = name.toLowerCase().includes(searchTerm.toLowerCase());
                            const matchesObservations = data.observations?.some(obs =>
                                obs.toLowerCase().includes(searchTerm.toLowerCase())
                            );

                            if (matchesName || matchesObservations) {
                                filteredEntities[type][name] = data;
                            }
                        });
                    });
                }

                // Temporarily replace data and render
                const originalData = this.memoryData.entities;
                this.memoryData.entities = filteredEntities;
                this.renderGraph();
                this.memoryData.entities = originalData;
            }

            updateZoom(value) {
                const svg = document.querySelector('#mermaidChart svg');
                if (svg) {
                    svg.style.transform = `scale(${value / 100})`;
                    svg.style.transformOrigin = 'top left';
                }
            }

            resetView() {
                this.selectedNode = null;
                document.getElementById('searchInput').value = '';
                document.getElementById('zoomSlider').value = '100';
                document.getElementById('zoomValue').textContent = '100%';
                this.updateZoom(100);
                this.renderGraph();

                const nodePanel = document.getElementById('nodePanel');
                nodePanel.innerHTML = '<div class="text-center text-slate-400 py-8">Click on a node in the graph to explore details</div>';
            }

            exportGraph() {
                const svg = document.querySelector('#mermaidChart svg');
                if (!svg) {
                    this.showNotification('No graph to export', 'error');
                    return;
                }

                // Create download link
                const svgData = new XMLSerializer().serializeToString(svg);
                const svgBlob = new Blob([svgData], {type: 'image/svg+xml;charset=utf-8'});
                const svgUrl = URL.createObjectURL(svgBlob);

                const downloadLink = document.createElement('a');
                downloadLink.href = svgUrl;
                downloadLink.download = `memory-codemap-${Date.now()}.svg`;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

                URL.revokeObjectURL(svgUrl);
                this.showNotification('Graph exported successfully!', 'success');
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            window.memoryCodeMap = new MemoryCodeMap();
        });

        // Make functions globally available for onclick handlers
        window.memoryCodeMap = null;
    </script>
</body>
</html>
