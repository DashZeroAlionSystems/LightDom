/**
 * GitHub Automation Service
 * 
 * Automates GitHub issue and PR creation with Copilot assignment
 * - Creates issues from error reports
 * - Assigns GitHub Copilot as assignee
 * - Creates draft PRs with AI-generated fixes
 * - Manages issue/PR lifecycle
 * 
 * @module services/github-automation
 */

import { EventEmitter } from 'events';
import { Octokit } from '@octokit/rest';
import crypto from 'crypto';

export class GitHubAutomationService extends EventEmitter {
  constructor(config = {}) {
    super();
    
    this.config = {
      db: config.db,
      githubToken: config.githubToken || process.env.GITHUB_TOKEN,
      repoOwner: config.repoOwner || process.env.GITHUB_REPO_OWNER,
      repoName: config.repoName || process.env.GITHUB_REPO_NAME,
      copilotUsername: config.copilotUsername || 'github-copilot[bot]',
      autoAssign: config.autoAssign !== false,
      createDraftPRs: config.createDraftPRs !== false,
      ...config,
    };
    
    if (!this.config.githubToken) {
      console.warn('âš ï¸  No GitHub token provided. GitHub automation will be limited.');
    } else {
      this.octokit = new Octokit({
        auth: this.config.githubToken,
      });
    }
    
    if (!this.config.db) {
      throw new Error('Database connection required for GitHubAutomationService');
    }
  }
  
  /**
   * Create GitHub issue from error report
   */
  async createIssueFromError(errorReportId) {
    if (!this.octokit) {
      throw new Error('GitHub token not configured');
    }
    
    console.log(`ðŸ“ Creating GitHub issue for error ${errorReportId}...`);
    
    // Get error report
    const error = await this.getErrorReport(errorReportId);
    
    if (!error) {
      throw new Error(`Error report ${errorReportId} not found`);
    }
    
    // Check if issue already exists
    const existingIssue = await this.findExistingIssue(error);
    
    if (existingIssue) {
      console.log(`â„¹ï¸  Issue already exists: #${existingIssue.number}`);
      return existingIssue;
    }
    
    // Generate issue title and body
    const title = this.generateIssueTitle(error);
    const body = this.generateIssueBody(error);
    const labels = this.generateIssueLabels(error);
    
    // Create issue
    const issue = await this.octokit.rest.issues.create({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      title,
      body,
      labels,
      assignees: this.config.autoAssign ? [this.config.copilotUsername] : [],
    });
    
    console.log(`âœ… Created issue #${issue.data.number}`);
    
    // Save issue reference to database
    await this.saveIssueReference(errorReportId, issue.data);
    
    this.emit('issue:created', {
      errorReportId,
      issueNumber: issue.data.number,
      issueUrl: issue.data.html_url,
    });
    
    return issue.data;
  }
  
  /**
   * Create GitHub issue from agent task
   */
  async createIssueFromTask(taskDescription, options = {}) {
    if (!this.octokit) {
      throw new Error('GitHub token not configured');
    }
    
    console.log(`ðŸ“ Creating GitHub issue for task...`);
    
    const {
      title = `Task: ${taskDescription.substring(0, 50)}`,
      labels = ['enhancement', 'ai-generated'],
      assignCopilot = true,
      priority = 'normal',
    } = options;
    
    const body = `## Task Description

${taskDescription}

## Details

- **Priority**: ${priority}
- **Generated by**: AI Agent
- **Created**: ${new Date().toISOString()}

## Acceptance Criteria

- [ ] Task completed successfully
- [ ] Tests added/updated
- [ ] Documentation updated

---
*This issue was automatically created by the AI agent system.*`;
    
    const issue = await this.octokit.rest.issues.create({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      title,
      body,
      labels,
      assignees: assignCopilot ? [this.config.copilotUsername] : [],
    });
    
    console.log(`âœ… Created task issue #${issue.data.number}`);
    
    this.emit('task-issue:created', {
      issueNumber: issue.data.number,
      issueUrl: issue.data.html_url,
    });
    
    return issue.data;
  }
  
  /**
   * Create draft PR with AI-generated fix
   */
  async createDraftPRWithFix(errorReportId, fix) {
    if (!this.octokit) {
      throw new Error('GitHub token not configured');
    }
    
    console.log(`ðŸ“ Creating draft PR for error ${errorReportId}...`);
    
    const error = await this.getErrorReport(errorReportId);
    
    if (!error) {
      throw new Error(`Error report ${errorReportId} not found`);
    }
    
    const branchName = `fix/error-${error.error_hash.substring(0, 8)}`;
    const title = `Fix: ${error.error_type} in ${error.component}`;
    const body = this.generatePRBody(error, fix);
    
    try {
      // Create PR
      const pr = await this.octokit.rest.pulls.create({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        title,
        body,
        head: branchName,
        base: 'main',
        draft: true,
      });
      
      // Assign Copilot to review
      if (this.config.autoAssign) {
        await this.octokit.rest.pulls.requestReviewers({
          owner: this.config.repoOwner,
          repo: this.config.repoName,
          pull_number: pr.data.number,
          reviewers: [this.config.copilotUsername],
        });
      }
      
      console.log(`âœ… Created draft PR #${pr.data.number}`);
      
      // Save PR reference
      await this.savePRReference(errorReportId, pr.data);
      
      this.emit('pr:created', {
        errorReportId,
        prNumber: pr.data.number,
        prUrl: pr.data.html_url,
      });
      
      return pr.data;
      
    } catch (error) {
      console.error('Failed to create PR:', error);
      throw error;
    }
  }
  
  /**
   * Continuously create tasks from error patterns
   */
  async startContinuousTaskCreation(options = {}) {
    const {
      interval = 300000, // 5 minutes
      minOccurrences = 3,
      enabled = true,
    } = options;
    
    if (!enabled) {
      console.log('â„¹ï¸  Continuous task creation is disabled');
      return;
    }
    
    console.log('ðŸ”„ Starting continuous task creation...');
    
    const processErrors = async () => {
      try {
        // Find errors that need issues created
        const errors = await this.findErrorsNeedingIssues(minOccurrences);
        
        console.log(`ðŸ“Š Found ${errors.length} errors needing issues`);
        
        for (const error of errors) {
          try {
            await this.createIssueFromError(error.id);
            
            // Wait a bit between creations to avoid rate limiting
            await new Promise(resolve => setTimeout(resolve, 2000));
            
          } catch (error) {
            console.error(`Failed to create issue for error ${error.id}:`, error.message);
          }
        }
        
      } catch (error) {
        console.error('Error in continuous task creation:', error);
      }
    };
    
    // Initial run
    await processErrors();
    
    // Schedule periodic runs
    this.taskCreationInterval = setInterval(processErrors, interval);
    
    console.log(`âœ… Continuous task creation started (interval: ${interval}ms)`);
  }
  
  /**
   * Stop continuous task creation
   */
  stopContinuousTaskCreation() {
    if (this.taskCreationInterval) {
      clearInterval(this.taskCreationInterval);
      this.taskCreationInterval = null;
      console.log('ðŸ›‘ Continuous task creation stopped');
    }
  }
  
  /**
   * Generate issue title from error
   */
  generateIssueTitle(error) {
    return `[${error.severity.toUpperCase()}] ${error.error_type} in ${error.component}`;
  }
  
  /**
   * Generate issue body from error
   */
  generateIssueBody(error) {
    return `## Error Details

- **Type**: ${error.error_type}
- **Component**: ${error.component}
- **Service**: ${error.service || 'N/A'}
- **Severity**: ${error.severity}
- **Occurrences**: ${error.occurrence_count}
- **First Seen**: ${error.first_seen_at}
- **Last Seen**: ${error.last_seen_at}

## Error Message

\`\`\`
${error.message}
\`\`\`

## Stack Trace

\`\`\`
${error.stack_trace || 'N/A'}
\`\`\`

## Context

\`\`\`json
${JSON.stringify(error.context, null, 2)}
\`\`\`

## Recommended Actions

${error.analysis_result ? `
### AI Analysis

${JSON.stringify(error.analysis_result, null, 2)}
` : '*Awaiting AI analysis...*'}

---
*This issue was automatically created from error report \`${error.id}\`*`;
  }
  
  /**
   * Generate PR body from error and fix
   */
  generatePRBody(error, fix) {
    return `## Description

This PR fixes the following error:

**${error.error_type}** in **${error.component}**

## Error Details

- **Occurrences**: ${error.occurrence_count}
- **Severity**: ${error.severity}
- **Error Hash**: \`${error.error_hash}\`

## Changes Made

${fix.explanation || 'AI-generated fix'}

## Testing

- [ ] Unit tests added/updated
- [ ] Integration tests pass
- [ ] Manual testing completed

## Related Issues

Closes #[issue-number]

---
*This PR was automatically generated by the AI agent system.*
*Please review carefully before merging.*`;
  }
  
  /**
   * Generate issue labels from error
   */
  generateIssueLabels(error) {
    const labels = ['bug', 'ai-generated'];
    
    // Add severity label
    labels.push(`severity:${error.severity}`);
    
    // Add component label if available
    if (error.component) {
      labels.push(`component:${error.component.toLowerCase().replace(/\s+/g, '-')}`);
    }
    
    return labels;
  }
  
  /**
   * Find existing issue for error
   */
  async findExistingIssue(error) {
    try {
      const query = `
        SELECT github_issue_number, github_issue_url
        FROM error_actions
        WHERE error_report_id = $1
          AND action_type = 'create_ticket'
          AND action_status = 'completed'
        ORDER BY created_at DESC
        LIMIT 1
      `;
      
      const result = await this.config.db.query(query, [error.id]);
      
      if (result.rows.length > 0) {
        const row = result.rows[0];
        return {
          number: row.github_issue_number,
          url: row.github_issue_url,
        };
      }
    } catch (error) {
      console.debug('Failed to find existing issue:', error.message);
    }
    
    return null;
  }
  
  /**
   * Find errors that need issues created
   */
  async findErrorsNeedingIssues(minOccurrences = 3) {
    const query = `
      SELECT er.*
      FROM error_reports er
      LEFT JOIN error_actions ea ON ea.error_report_id = er.id
        AND ea.action_type = 'create_ticket'
      WHERE er.status IN ('new', 'analyzed')
        AND er.severity IN ('critical', 'error')
        AND er.occurrence_count >= $1
        AND ea.id IS NULL
      ORDER BY er.severity, er.occurrence_count DESC
      LIMIT 10
    `;
    
    const result = await this.config.db.query(query, [minOccurrences]);
    return result.rows;
  }
  
  /**
   * Get error report from database
   */
  async getErrorReport(errorReportId) {
    const query = `
      SELECT * FROM error_reports
      WHERE id = $1
    `;
    
    const result = await this.config.db.query(query, [errorReportId]);
    return result.rows[0] || null;
  }
  
  /**
   * Save issue reference to database
   */
  async saveIssueReference(errorReportId, issue) {
    const query = `
      INSERT INTO error_actions
        (error_report_id, action_type, action_status, recommendation, ticket_id, created_at)
      VALUES ($1, $2, $3, $4, $5, NOW())
      RETURNING id
    `;
    
    try {
      const result = await this.config.db.query(query, [
        errorReportId,
        'create_ticket',
        'completed',
        JSON.stringify({
          issueNumber: issue.number,
          issueUrl: issue.html_url,
        }),
        issue.number.toString()
      ]);
      
      return result.rows[0].id;
    } catch (error) {
      console.debug('Failed to save issue reference:', error.message);
      return null;
    }
  }
  
  /**
   * Save PR reference to database
   */
  async savePRReference(errorReportId, pr) {
    const query = `
      INSERT INTO error_actions
        (error_report_id, action_type, action_status, recommendation, pr_url, branch_name, created_at)
      VALUES ($1, $2, $3, $4, $5, $6, NOW())
      RETURNING id
    `;
    
    try {
      const result = await this.config.db.query(query, [
        errorReportId,
        'generate_pr',
        'completed',
        JSON.stringify({
          prNumber: pr.number,
          prUrl: pr.html_url,
        }),
        pr.html_url,
        pr.head.ref
      ]);
      
      return result.rows[0].id;
    } catch (error) {
      console.debug('Failed to save PR reference:', error.message);
      return null;
    }
  }
  
  /**
   * Update issue with new information
   */
  async updateIssue(issueNumber, updates) {
    if (!this.octokit) {
      throw new Error('GitHub token not configured');
    }
    
    try {
      const issue = await this.octokit.rest.issues.update({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        issue_number: issueNumber,
        ...updates,
      });
      
      return issue.data;
    } catch (error) {
      console.error(`Failed to update issue #${issueNumber}:`, error);
      throw error;
    }
  }
  
  /**
   * Add comment to issue
   */
  async addIssueComment(issueNumber, comment) {
    if (!this.octokit) {
      throw new Error('GitHub token not configured');
    }
    
    try {
      const result = await this.octokit.rest.issues.createComment({
        owner: this.config.repoOwner,
        repo: this.config.repoName,
        issue_number: issueNumber,
        body: comment,
      });
      
      return result.data;
    } catch (error) {
      console.error(`Failed to add comment to issue #${issueNumber}:`, error);
      throw error;
    }
  }
}

export default GitHubAutomationService;
