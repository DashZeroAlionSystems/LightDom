version: '3.8'

services:
  redis:
    image: redis:7-alpine
    container_name: lightdom-redis-dev
    ports:
      - '6379:6379'

  postgres-dev:
    image: postgres:15-alpine
    container_name: lightdom-postgres-dev
    environment:
      POSTGRES_DB: lightdom_dev
      POSTGRES_USER: lightdom_user
      POSTGRES_PASSWORD: lightdom_password
    ports:
      - '5433:5432'
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data

  worker:
    build:
      context: .
      dockerfile: docker/worker.Dockerfile
    container_name: lightdom-headless-worker
    environment:
      - TARGET_URL=${TARGET_URL}
      - API_URL=${API_URL}
      - DB_HOST=postgres-dev
      - DB_PORT=5432
      - DB_NAME=lightdom_dev
      - DB_USER=lightdom_user
      - DB_PASSWORD=lightdom_password
    depends_on:
      - postgres-dev
      - redis
    # You can override the command to run a specific url:
    # command: ["node","workers/headless-worker.js","https://example.com"]

  # Optional one-shot DB bootstrap runner. This will install node deps inside
  # the container, wait for Postgres to be reachable at the service name
  # `postgres-dev`, then run `npm run db:bootstrap`. It's useful for CI/local
  # dev where you want the DB schema created automatically.
  db-bootstrap:
    image: node:18-alpine
    container_name: lightdom-db-bootstrap
    working_dir: /workspace
    volumes:
      - ./:/workspace:cached
    depends_on:
      - postgres-dev
    restart: 'no'
    entrypoint: ['sh', '-c']
    command: >
      apk add --no-cache python3 make g++ netcat-openbsd && \
      cd /workspace && \
      npm ci --omit=dev && \
      until nc -z postgres-dev 5432; do echo "waiting for postgres..."; sleep 1; done && \
      npm run db:bootstrap

volumes:
  postgres_dev_data:
    driver: local
