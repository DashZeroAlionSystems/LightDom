{
  "dom_analysis_workflow": {
    "name": "DOM Analysis Workflow",
    "description": "Comprehensive DOM analysis for optimization",
    "nodes": [
      {
        "id": "webhook-trigger",
        "type": "n8n-nodes-base.webhook",
        "name": "Webhook Trigger",
        "parameters": {
          "httpMethod": "POST",
          "path": "dom-analysis",
          "responseMode": "responseNode"
        },
        "position": [100, 200]
      },
      {
        "id": "validate-input",
        "type": "n8n-nodes-base.function",
        "name": "Validate Input",
        "parameters": {
          "functionCode": "// Validate input data\nconst { url, analysisType = 'full' } = $input.first().json;\n\nif (!url) {\n  throw new Error('URL is required');\n}\n\nreturn [{\n  json: {\n    url,\n    analysisType,\n    timestamp: new Date().toISOString()\n  }\n}];"
        },
        "position": [300, 200]
      },
      {
        "id": "create-task",
        "type": "n8n-nodes-base.httpRequest",
        "name": "Create DOM Analysis Task",
        "parameters": {
          "method": "POST",
          "url": "http://localhost:3001/api/tasks/dom-analysis",
          "headers": {
            "Content-Type": "application/json"
          },
          "body": "={{ JSON.stringify({ url: $json.url, analysisType: $json.analysisType, priority: 8 }) }}"
        },
        "position": [500, 200]
      },
      {
        "id": "wait-for-completion",
        "type": "n8n-nodes-base.wait",
        "name": "Wait for Task Completion",
        "parameters": {
          "amount": 5,
          "unit": "seconds"
        },
        "position": [700, 200]
      },
      {
        "id": "check-task-status",
        "type": "n8n-nodes-base.httpRequest",
        "name": "Check Task Status",
        "parameters": {
          "method": "GET",
          "url": "=http://localhost:3001/api/tasks/{{ $json.taskId }}"
        },
        "position": [900, 200]
      },
      {
        "id": "process-results",
        "type": "n8n-nodes-base.function",
        "name": "Process Results",
        "parameters": {
          "functionCode": "// Process DOM analysis results\nconst task = $input.first().json.task;\n\nif (task.status === 'completed') {\n  const analysis = task.result;\n  \n  // Extract key metrics\n  const metrics = {\n    totalElements: analysis.totalElements,\n    performanceScore: analysis.performanceMetrics ? {\n      domContentLoaded: analysis.performanceMetrics.domContentLoaded,\n      loadComplete: analysis.performanceMetrics.loadComplete,\n      firstContentfulPaint: analysis.performanceMetrics.firstContentfulPaint\n    } : null,\n    imageOptimization: analysis.imageAnalysis ? {\n      totalImages: analysis.imageAnalysis.total,\n      withoutAlt: analysis.imageAnalysis.withoutAlt,\n      oversized: analysis.imageAnalysis.oversized\n    } : null,\n    optimizationSuggestions: []\n  };\n  \n  // Generate optimization suggestions\n  if (analysis.imageAnalysis && analysis.imageAnalysis.withoutAlt > 0) {\n    metrics.optimizationSuggestions.push({\n      type: 'accessibility',\n      message: `Add alt text to ${analysis.imageAnalysis.withoutAlt} images`,\n      priority: 'high'\n    });\n  }\n  \n  if (analysis.scriptAnalysis && analysis.scriptAnalysis.inline > 5) {\n    metrics.optimizationSuggestions.push({\n      type: 'performance',\n      message: `Consider moving ${analysis.scriptAnalysis.inline} inline scripts to external files`,\n      priority: 'medium'\n    });\n  }\n  \n  return [{\n    json: {\n      success: true,\n      url: task.parameters.url,\n      analysis: metrics,\n      taskId: task.id,\n      completedAt: task.completedAt\n    }\n  }];\n} else if (task.status === 'failed') {\n  return [{\n    json: {\n      success: false,\n      error: task.error,\n      taskId: task.id\n    }\n  }];\n} else {\n  // Task still running, wait more\n  return [{\n    json: {\n      success: false,\n      status: 'running',\n      taskId: task.id,\n      waitMore: true\n    }\n  }];\n}"
        },
        "position": [1100, 200]
      },
      {
        "id": "response",
        "type": "n8n-nodes-base.respondToWebhook",
        "name": "Response",
        "parameters": {
          "respondWith": "json",
          "responseBody": "={{ JSON.stringify($json) }}"
        },
        "position": [1300, 200]
      }
    ],
    "connections": {
      "webhook-trigger": {
        "main": [["validate-input"]]\n      },\n      "validate-input": {\n        "main": [["create-task"]]\n      },\n      "create-task": {\n        "main": [["wait-for-completion"]]\n      },\n      "wait-for-completion": {\n        "main": [["check-task-status"]]\n      },\n      "check-task-status": {\n        "main": [["process-results"]]\n      },\n      "process-results": {\n        "main": [["response"]]\n      }\n    }\n  },\n  "javascript_execution_workflow": {\n    "name": "JavaScript Execution Workflow",\n    "description": "Execute custom JavaScript functions in headless Chrome",\n    "nodes": [\n      {\n        "id": "webhook-trigger",\n        "type": "n8n-nodes-base.webhook",\n        "name": "Webhook Trigger",\n        "parameters": {\n          "httpMethod": "POST",\n          "path": "execute-js",\n          "responseMode": "responseNode"\n        },\n        "position": [100, 200]\n      },\n      {\n        "id": "validate-script",\n        "type": "n8n-nodes-base.function",\n        "name": "Validate Script",\n        "parameters": {\n          "functionCode": "// Validate JavaScript execution request\\nconst { script, url, args = [] } = $input.first().json;\\n\\nif (!script) {\\n  throw new Error('Script is required');\\n}\\n\\n// Basic script validation\\nif (script.includes('eval(') || script.includes('Function(')) {\\n  throw new Error('Dangerous script patterns detected');\\n}\\n\\nreturn [{\\n  json: {\\n    script,\\n    url,\\n    args,\\n    timestamp: new Date().toISOString()\\n  }\\n}];"\n        },\n        "position": [300, 200]\n      },\n      {\n        "id": "execute-script",\n        "type": "n8n-nodes-base.httpRequest",\n        "name": "Execute JavaScript",\n        "parameters": {\n          "method": "POST",\n          "url": "http://localhost:3001/api/execute/javascript",\n          "headers": {\n            "Content-Type": "application/json"\n          },\n          "body": "={{ JSON.stringify({ script: $json.script, url: $json.url, args: $json.args, timeout: 30000 }) }}"\n        },\n        "position": [500, 200]\n      },\n      {\n        "id": "process-result",\n        "type": "n8n-nodes-base.function",\n        "name": "Process Result",\n        "parameters": {\n          "functionCode": "// Process JavaScript execution result\\nconst response = $input.first().json;\\n\\nif (response.success) {\\n  return [{\\n    json: {\\n      success: true,\\n      result: response.result,\\n      executionTime: response.executionTime,\\n      timestamp: new Date().toISOString()\\n    }\\n  }];\\n} else {\\n  return [{\\n    json: {\\n      success: false,\\n      error: response.error || 'Script execution failed',\\n      timestamp: new Date().toISOString()\\n    }\\n  }];\\n}"\n        },\n        "position": [700, 200]\n      },\n      {\n        "id": "response",\n        "type": "n8n-nodes-base.respondToWebhook",\n        "name": "Response",\n        "parameters": {\n          "respondWith": "json",\n          "responseBody": "={{ JSON.stringify($json) }}"\n        },\n        "position": [900, 200]\n      }\n    ],\n    "connections": {\n      "webhook-trigger": {\n        "main": [["validate-script"]]\n      },\n      "validate-script": {\n        "main": [["execute-script"]]\n      },\n      "execute-script": {\n        "main": [["process-result"]]\n      },\n      "process-result": {\n        "main": [["response"]]\n      }\n    }\n  },\n  "cursor_api_workflow": {\n    "name": "Cursor API Integration Workflow",\n    "description": "Execute Cursor API functions through n8n",\n    "nodes": [\n      {\n        "id": "webhook-trigger",\n        "type": "n8n-nodes-base.webhook",\n        "name": "Webhook Trigger",\n        "parameters": {\n          "httpMethod": "POST",\n          "path": "cursor-api",\n          "responseMode": "responseNode"\n        },\n        "position": [100, 200]\n      },\n      {\n        "id": "validate-function",\n        "type": "n8n-nodes-base.function",\n        "name": "Validate Function",\n        "parameters": {\n          "functionCode": "// Validate Cursor API function request\\nconst { functionName, parameters = {}, url } = $input.first().json;\\n\\nconst allowedFunctions = ['analyzeDOM', 'extractText', 'getTitle', 'getMetaTags', 'screenshot'];\\n\\nif (!functionName) {\\n  throw new Error('Function name is required');\\n}\\n\\nif (!allowedFunctions.includes(functionName)) {\\n  throw new Error(`Function '${functionName}' is not allowed`);\\n}\\n\\nreturn [{\\n  json: {\\n    functionName,\\n    parameters,\\n    url,\\n    timestamp: new Date().toISOString()\\n  }\\n}];"\n        },\n        "position": [300, 200]\n      },\n      {\n        "id": "execute-cursor-function",\n        "type": "n8n-nodes-base.httpRequest",\n        "name": "Execute Cursor Function",\n        "parameters": {\n          "method": "POST",\n          "url": "http://localhost:3001/api/cursor/execute",\n          "headers": {\n            "Content-Type": "application/json"\n          },\n          "body": "={{ JSON.stringify({ functionName: $json.functionName, parameters: $json.parameters, url: $json.url, timeout: 30000 }) }}"\n        },\n        "position": [500, 200]\n      },\n      {\n        "id": "process-cursor-result",\n        "type": "n8n-nodes-base.function",\n        "name": "Process Cursor Result",\n        "parameters": {\n          "functionCode": "// Process Cursor API execution result\\nconst response = $input.first().json;\\n\\nif (response.success) {\\n  return [{\\n    json: {\\n      success: true,\\n      functionName: response.functionName,\\n      result: response.result,\\n      executionTime: response.executionTime,\\n      timestamp: new Date().toISOString()\\n    }\\n  }];\\n} else {\\n  return [{\\n    json: {\\n      success: false,\\n      functionName: response.functionName,\\n      error: response.details || 'Function execution failed',\\n      timestamp: new Date().toISOString()\\n    }\\n  }];\\n}"\n        },\n        "position": [700, 200]\n      },\n      {\n        "id": "response",\n        "type": "n8n-nodes-base.respondToWebhook",\n        "name": "Response",\n        "parameters": {\n          "respondWith": "json",\n          "responseBody": "={{ JSON.stringify($json) }}"\n        },\n        "position": [900, 200]\n      }\n    ],\n    "connections": {\n      "webhook-trigger": {\n        "main": [["validate-function"]]\n      },\n      "validate-function": {\n        "main": [["execute-cursor-function"]]\n      },\n      "execute-cursor-function": {\n        "main": [["process-cursor-result"]]\n      },\n      "process-cursor-result": {\n        "main": [["response"]]\n      }\n    }\n  },\n  "optimization_pipeline_workflow": {\n    "name": "DOM Optimization Pipeline",\n    "description": "Complete DOM optimization pipeline with Cursor and n8n integration",\n    "nodes": [\n      {\n        "id": "webhook-trigger",\n        "type": "n8n-nodes-base.webhook",\n        "name": "Webhook Trigger",\n        "parameters": {\n          "httpMethod": "POST",\n          "path": "optimize-dom",\n          "responseMode": "responseNode"\n        },\n        "position": [100, 200]\n      },\n      {\n        "id": "validate-url",\n        "type": "n8n-nodes-base.function",\n        "name": "Validate URL",\n        "parameters": {\n          "functionCode": "// Validate URL for optimization\\nconst { url, optimizationType = 'full' } = $input.first().json;\\n\\nif (!url) {\\n  throw new Error('URL is required');\\n}\\n\\ntry {\\n  new URL(url);\\n} catch (e) {\\n  throw new Error('Invalid URL format');\\n}\\n\\nreturn [{\\n  json: {\\n    url,\\n    optimizationType,\\n    timestamp: new Date().toISOString()\\n  }\\n}];"\n        },\n        "position": [300, 200]\n      },\n      {\n        "id": "analyze-dom",\n        "type": "n8n-nodes-base.httpRequest",\n        "name": "Analyze DOM",\n        "parameters": {\n          "method": "POST",\n          "url": "http://localhost:3001/api/cursor/execute",\n          "headers": {\n            "Content-Type": "application/json"\n          },\n          "body": "={{ JSON.stringify({ functionName: 'analyzeDOM', url: $json.url, timeout: 30000 }) }}"\n        },\n        "position": [500, 200]\n      },\n      {\n        "id": "extract-text",\n        "type": "n8n-nodes-base.httpRequest",\n        "name": "Extract Text Content",\n        "parameters": {\n          "method": "POST",\n          "url": "http://localhost:3001/api/cursor/execute",\n          "headers": {\n            "Content-Type": "application/json"\n          },\n          "body": "={{ JSON.stringify({ functionName: 'extractText', url: $json.url, timeout: 30000 }) }}"\n        },\n        "position": [500, 400]\n      },\n      {\n        "id": "get-meta-tags",\n        "type": "n8n-nodes-base.httpRequest",\n        "name": "Get Meta Tags",\n        "parameters": {\n          "method": "POST",\n          "url": "http://localhost:3001/api/cursor/execute",\n          "headers": {\n            "Content-Type": "application/json"\n          },\n          "body": "={{ JSON.stringify({ functionName: 'getMetaTags', url: $json.url, timeout: 30000 }) }}"\n        },\n        "position": [500, 600]\n      },\n      {\n        "id": "merge-analysis",\n        "type": "n8n-nodes-base.merge",\n        "name": "Merge Analysis",\n        "parameters": {\n          "mode": "combine",\n          "combineBy": "combineAll"\n        },\n        "position": [700, 400]\n      },\n      {\n        "id": "generate-optimizations",\n        "type": "n8n-nodes-base.function",\n        "name": "Generate Optimizations",\n        "parameters": {\n          "functionCode": "// Generate optimization recommendations\\nconst items = $input.all();\\n\\nconst domAnalysis = items.find(item => item.json.functionName === 'analyzeDOM');\\nconst textContent = items.find(item => item.json.functionName === 'extractText');\\nconst metaTags = items.find(item => item.json.functionName === 'getMetaTags');\\n\\nconst optimizations = [];\\n\\nif (domAnalysis && domAnalysis.json.success) {\\n  const analysis = domAnalysis.json.result;\\n  \\n  // Image optimizations\\n  if (analysis.images > 0) {\\n    optimizations.push({\\n      type: 'image',\\n      priority: 'high',\\n      message: `Optimize ${analysis.images} images for better performance`,\\n      suggestions: [\\n        'Convert images to WebP format',\\n        'Implement lazy loading',\\n        'Add proper alt attributes',\\n        'Optimize image sizes'\n      ]\n    });\n  }\n  \n  // Script optimizations\n  if (analysis.scripts > 0) {\n    optimizations.push({\n      type: 'script',\n      priority: 'medium',\n      message: `Optimize ${analysis.scripts} scripts for better performance`,\n      suggestions: [\n        'Minify JavaScript files',\n        'Use async/defer attributes',\n        'Combine multiple scripts',\n        'Remove unused scripts'\n      ]\n    });\n  }\n  \n  // Performance optimizations\n  if (analysis.performance && analysis.performance.domContentLoaded > 3000) {\n    optimizations.push({\n      type: 'performance',\n      priority: 'high',\n      message: 'DOM content loaded in ' + analysis.performance.domContentLoaded + 'ms (target: <3000ms)',\n      suggestions: [\n        'Optimize critical rendering path',\n        'Reduce DOM complexity',\n        'Minimize render-blocking resources',\n        'Use server-side rendering'\n      ]\n    });\n  }\n}\n\nif (textContent && textContent.json.success) {\n  const text = textContent.json.result;\n  const wordCount = text.split(' ').length;\n  \n  if (wordCount < 300) {\n    optimizations.push({\n      type: 'content',\n      priority: 'low',\n      message: `Page has ${wordCount} words (recommended: 300+)`,\n      suggestions: [\n        'Add more descriptive content',\n        'Include relevant keywords',\n        'Expand on key topics'\n      ]\n    });\n  }\n}\n\nif (metaTags && metaTags.json.success) {\n  const meta = metaTags.json.result;\n  \n  if (!meta.description) {\n    optimizations.push({\n      type: 'seo',\n      priority: 'high',\n      message: 'Missing meta description',\n      suggestions: [\n        'Add a compelling meta description (150-160 characters)',\n        'Include target keywords',\n        'Make it unique for each page'\n      ]\n    });\n  }\n  \n  if (!meta.keywords) {\n    optimizations.push({\n      type: 'seo',\n      priority: 'medium',\n      message: 'Missing meta keywords',\n      suggestions: [\n        'Add relevant keywords',\n        'Keep it under 10 keywords',\n        'Avoid keyword stuffing'\n      ]\n    });\n  }\n}\n\nreturn [{\n  json: {\n    url: domAnalysis?.json.url || 'unknown',\n    timestamp: new Date().toISOString(),\n    analysis: {\n      domAnalysis: domAnalysis?.json.result || null,\n      textContent: textContent?.json.result || null,\n      metaTags: metaTags?.json.result || null\n    },\n    optimizations,\n    summary: {\n      totalOptimizations: optimizations.length,\n      highPriority: optimizations.filter(o => o.priority === 'high').length,\n      mediumPriority: optimizations.filter(o => o.priority === 'medium').length,\n      lowPriority: optimizations.filter(o => o.priority === 'low').length\n    }\n  }\n}];"\n        },\n        "position": [900, 400]\n      },\n      {\n        "id": "response",\n        "type": "n8n-nodes-base.respondToWebhook",\n        "name": "Response",\n        "parameters": {\n          "respondWith": "json",\n          "responseBody": "={{ JSON.stringify($json) }}"\n        },\n        "position": [1100, 400]\n      }\n    ],\n    "connections": {\n      "webhook-trigger": {\n        "main": [["validate-url"]]\n      },\n      "validate-url": {\n        "main": [["analyze-dom", "extract-text", "get-meta-tags"]]\n      },\n      "analyze-dom": {\n        "main": [["merge-analysis"]]\n      },\n      "extract-text": {\n        "main": [["merge-analysis"]]\n      },\n      "get-meta-tags": {\n        "main": [["merge-analysis"]]\n      },\n      "merge-analysis": {\n        "main": [["generate-optimizations"]]\n      },\n      "generate-optimizations": {\n        "main": [["response"]]\n      }\n    }\n  }\n}\n
