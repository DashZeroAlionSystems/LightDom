/**
 * Puppeteer Testing Framework for React Components
 * 
 * Purpose: Automated testing framework for React components generated by neural networks
 * Features:
 * - Visual regression testing
 * - Component rendering verification
 * - AI-generated component validation
 * - Screenshot comparison
 * - Accessibility testing
 */

import puppeteer, { Browser, Page } from 'puppeteer';
import { spawn, ChildProcess } from 'child_process';
import path from 'path';
import fs from 'fs/promises';

export interface ComponentTestConfig {
  componentPath: string;
  props?: Record<string, any>;
  variants?: string[];
  viewport?: { width: number; height: number };
  baselineDir?: string;
  screenshotDir?: string;
}

export interface TestResult {
  passed: boolean;
  componentName: string;
  variant?: string;
  errors?: string[];
  warnings?: string[];
  screenshots?: {
    current: string;
    baseline?: string;
    diff?: string;
  };
  accessibilityViolations?: any[];
  renderTime?: number;
}

export class PuppeteerComponentTester {
  private browser: Browser | null = null;
  private devServer: ChildProcess | null = null;
  private baseUrl: string;
  private port: number;
  
  constructor(port: number = 3000) {
    this.port = port;
    this.baseUrl = `http://localhost:${port}`;
  }
  
  /**
   * Initialize the test environment
   */
  async initialize(): Promise<void> {
    console.log('üöÄ Initializing Puppeteer test environment...');
    
    // Start dev server
    await this.startDevServer();
    
    // Launch browser
    this.browser = await puppeteer.launch({
      headless: process.env.HEADLESS !== 'false',
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
      ],
    });
    
    console.log('‚úÖ Puppeteer initialized');
  }
  
  /**
   * Start development server for testing
   */
  private async startDevServer(): Promise<void> {
    return new Promise((resolve, reject) => {
      console.log('üì¶ Starting development server...');
      
      this.devServer = spawn('npm', ['run', 'dev'], {
        stdio: 'pipe',
        env: {
          ...process.env,
          PORT: this.port.toString(),
          NODE_ENV: 'test',
        },
      });
      
      this.devServer.stdout?.on('data', (data) => {
        const output = data.toString();
        if (output.includes('Local:') || output.includes('ready')) {
          console.log('‚úÖ Development server ready');
          resolve();
        }
      });
      
      this.devServer.stderr?.on('data', (data) => {
        console.error('Dev server error:', data.toString());
      });
      
      this.devServer.on('error', (error) => {
        reject(error);
      });
      
      // Timeout after 60 seconds
      setTimeout(() => {
        resolve(); // Resolve anyway, server might be ready
      }, 60000);
    });
  }
  
  /**
   * Test a React component
   */
  async testComponent(config: ComponentTestConfig): Promise<TestResult> {
    if (!this.browser) {
      throw new Error('Browser not initialized. Call initialize() first.');
    }
    
    const componentName = path.basename(config.componentPath, '.tsx');
    console.log(`\nüß™ Testing component: ${componentName}`);
    
    const page = await this.browser.newPage();
    
    try {
      // Set viewport
      if (config.viewport) {
        await page.setViewport(config.viewport);
      }
      
      const result: TestResult = {
        passed: true,
        componentName,
        errors: [],
        warnings: [],
      };
      
      // Navigate to component test page
      const testUrl = this.buildTestUrl(componentName, config.props);
      
      const startTime = Date.now();
      await page.goto(testUrl, { waitUntil: 'networkidle0', timeout: 30000 });
      result.renderTime = Date.now() - startTime;
      
      // Check for React errors
      const consoleErrors = await this.checkConsoleErrors(page);
      if (consoleErrors.length > 0) {
        result.passed = false;
        result.errors = consoleErrors;
      }
      
      // Run accessibility tests
      const a11yViolations = await this.runAccessibilityTests(page);
      if (a11yViolations.length > 0) {
        result.accessibilityViolations = a11yViolations;
        result.warnings?.push(`Found ${a11yViolations.length} accessibility violations`);
      }
      
      // Take screenshot
      const screenshotPath = await this.takeScreenshot(page, componentName, config);
      result.screenshots = { current: screenshotPath };
      
      // Compare with baseline if exists
      if (config.baselineDir) {
        const comparison = await this.compareWithBaseline(
          screenshotPath,
          componentName,
          config.baselineDir
        );
        if (comparison) {
          result.screenshots.baseline = comparison.baseline;
          result.screenshots.diff = comparison.diff;
          if (comparison.hasDifferences) {
            result.warnings?.push('Visual differences detected from baseline');
          }
        }
      }
      
      // Test variants if specified
      if (config.variants && config.variants.length > 0) {
        for (const variant of config.variants) {
          await this.testVariant(page, componentName, variant, config);
        }
      }
      
      console.log(`${result.passed ? '‚úÖ' : '‚ùå'} ${componentName}: ${result.passed ? 'PASSED' : 'FAILED'}`);
      
      return result;
      
    } catch (error: any) {
      console.error(`‚ùå Error testing ${componentName}:`, error.message);
      return {
        passed: false,
        componentName,
        errors: [error.message],
      };
    } finally {
      await page.close();
    }
  }
  
  /**
   * Test AI-generated components
   */
  async testAIGeneratedComponent(
    componentCode: string,
    testProps?: Record<string, any>
  ): Promise<TestResult> {
    console.log('ü§ñ Testing AI-generated component...');
    
    // Create temporary component file
    const tempDir = path.join(process.cwd(), 'test', 'temp');
    await fs.mkdir(tempDir, { recursive: true });
    
    const componentPath = path.join(tempDir, 'AIGeneratedComponent.tsx');
    await fs.writeFile(componentPath, componentCode, 'utf-8');
    
    try {
      const result = await this.testComponent({
        componentPath,
        props: testProps,
      });
      
      // Cleanup
      await fs.unlink(componentPath);
      
      return result;
    } catch (error: any) {
      return {
        passed: false,
        componentName: 'AIGeneratedComponent',
        errors: [error.message],
      };
    }
  }
  
  /**
   * Build test URL for component
   */
  private buildTestUrl(componentName: string, props?: Record<string, any>): string {
    const params = new URLSearchParams();
    if (props) {
      params.set('props', JSON.stringify(props));
    }
    return `${this.baseUrl}/test/component/${componentName}?${params.toString()}`;
  }
  
  /**
   * Check for console errors
   */
  private async checkConsoleErrors(page: Page): Promise<string[]> {
    const errors: string[] = [];
    
    page.on('console', (msg) => {
      if (msg.type() === 'error') {
        errors.push(msg.text());
      }
    });
    
    page.on('pageerror', (error) => {
      errors.push(error.message);
    });
    
    return errors;
  }
  
  /**
   * Run accessibility tests using axe-core
   */
  private async runAccessibilityTests(page: Page): Promise<any[]> {
    try {
      // Inject axe-core
      await page.addScriptTag({
        url: 'https://cdnjs.cloudflare.com/ajax/libs/axe-core/4.7.2/axe.min.js',
      });
      
      // Run axe
      const results = await page.evaluate(() => {
        return (window as any).axe.run();
      });
      
      return results.violations || [];
    } catch (error) {
      console.warn('Could not run accessibility tests:', error);
      return [];
    }
  }
  
  /**
   * Take screenshot of component
   */
  private async takeScreenshot(
    page: Page,
    componentName: string,
    config: ComponentTestConfig
  ): Promise<string> {
    const screenshotDir = config.screenshotDir || path.join(process.cwd(), 'test', 'screenshots');
    await fs.mkdir(screenshotDir, { recursive: true });
    
    const filename = `${componentName}-${Date.now()}.png`;
    const filepath = path.join(screenshotDir, filename);
    
    await page.screenshot({
      path: filepath,
      fullPage: true,
    });
    
    return filepath;
  }
  
  /**
   * Compare screenshot with baseline
   */
  private async compareWithBaseline(
    currentPath: string,
    componentName: string,
    baselineDir: string
  ): Promise<{ baseline: string; diff: string; hasDifferences: boolean } | null> {
    const baselinePath = path.join(baselineDir, `${componentName}-baseline.png`);
    
    try {
      await fs.access(baselinePath);
      
      // TODO: Implement image comparison using pixelmatch or similar
      // For now, just return paths
      return {
        baseline: baselinePath,
        diff: currentPath.replace('.png', '-diff.png'),
        hasDifferences: false,
      };
    } catch {
      // Baseline doesn't exist
      console.log(`üì∏ Creating baseline for ${componentName}`);
      await fs.mkdir(baselineDir, { recursive: true });
      await fs.copyFile(currentPath, baselinePath);
      return null;
    }
  }
  
  /**
   * Test component variant
   */
  private async testVariant(
    page: Page,
    componentName: string,
    variant: string,
    config: ComponentTestConfig
  ): Promise<void> {
    console.log(`  üîÑ Testing variant: ${variant}`);
    
    const variantUrl = this.buildTestUrl(componentName, {
      ...config.props,
      variant,
    });
    
    await page.goto(variantUrl, { waitUntil: 'networkidle0' });
    
    const screenshotDir = config.screenshotDir || path.join(process.cwd(), 'test', 'screenshots');
    const filename = `${componentName}-${variant}-${Date.now()}.png`;
    const filepath = path.join(screenshotDir, filename);
    
    await page.screenshot({ path: filepath, fullPage: true });
  }
  
  /**
   * Run batch tests on multiple components
   */
  async runBatchTests(configs: ComponentTestConfig[]): Promise<TestResult[]> {
    console.log(`\nüìã Running batch tests on ${configs.length} components...\n`);
    
    const results: TestResult[] = [];
    
    for (const config of configs) {
      const result = await this.testComponent(config);
      results.push(result);
    }
    
    // Print summary
    this.printSummary(results);
    
    return results;
  }
  
  /**
   * Print test summary
   */
  private printSummary(results: TestResult[]): void {
    console.log('\n' + '='.repeat(60));
    console.log('üìä TEST SUMMARY');
    console.log('='.repeat(60));
    
    const passed = results.filter(r => r.passed).length;
    const failed = results.filter(r => !r.passed).length;
    
    console.log(`‚úÖ Passed: ${passed}`);
    console.log(`‚ùå Failed: ${failed}`);
    console.log(`üìù Total: ${results.length}`);
    
    if (failed > 0) {
      console.log('\nFailed components:');
      results
        .filter(r => !r.passed)
        .forEach(r => {
          console.log(`  - ${r.componentName}`);
          r.errors?.forEach(err => console.log(`    ‚ùå ${err}`));
        });
    }
    
    const totalWarnings = results.reduce((sum, r) => sum + (r.warnings?.length || 0), 0);
    if (totalWarnings > 0) {
      console.log(`\n‚ö†Ô∏è  Total warnings: ${totalWarnings}`);
    }
    
    console.log('='.repeat(60) + '\n');
  }
  
  /**
   * Cleanup and close browser
   */
  async cleanup(): Promise<void> {
    console.log('\nüßπ Cleaning up...');
    
    if (this.browser) {
      await this.browser.close();
    }
    
    if (this.devServer) {
      this.devServer.kill();
    }
    
    console.log('‚úÖ Cleanup complete');
  }
}

/**
 * Helper function to run component tests
 */
export async function runComponentTests(configs: ComponentTestConfig[]): Promise<void> {
  const tester = new PuppeteerComponentTester();
  
  try {
    await tester.initialize();
    const results = await tester.runBatchTests(configs);
    
    // Exit with error code if any tests failed
    const hasFailures = results.some(r => !r.passed);
    process.exit(hasFailures ? 1 : 0);
  } catch (error) {
    console.error('Fatal error:', error);
    process.exit(1);
  } finally {
    await tester.cleanup();
  }
}

// Export for use in other test files
export default PuppeteerComponentTester;
