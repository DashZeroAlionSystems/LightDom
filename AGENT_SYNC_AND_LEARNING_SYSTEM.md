# Agent Sync and Self-Learning System

Comprehensive system for agent synchronization, auto-configuration generation, and DeepSeek-managed self-learning orchestration.

## Overview

This system enables:
- **Real-time two-way communication** between agents and data sources
- **Automatic configuration generation** from patterns
- **Self-learning orchestration** with DeepSeek managing task improvements
- **Pattern-based optimization** with minimal cost
- **Simulation-first development** for all changes

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                  Agent Sync & Learning System                │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐  ┌───────────────┐  ┌──────────────────┐ │
│  │  Agent Sync  │  │  Auto-Config  │  │  Self-Learning   │ │
│  │   Service    │  │   Generation  │  │  Orchestration   │ │
│  └──────────────┘  └───────────────┘  └──────────────────┘ │
│         │                  │                     │           │
│         ▼                  ▼                     ▼           │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              Database Layer (8 tables)                │  │
│  │  • Sync Channels  • Auto Configs  • Learning Patterns│  │
│  │  • Sync Events    • Test Results  • Optimizations    │  │
│  │  • State Snapshots• Research Campaigns • Metrics     │  │
│  └──────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

## Quick Start

### 1. Install Dependencies

```bash
npm install
```

### 2. Run Database Migration

```bash
psql -U postgres -d lightdom -f database/migrations/204-agent-sync-and-learning.sql
```

### 3. Start Using the System

```typescript
import { AgentSyncService, AutoConfigGenerationService, SelfLearningOrchestrationService } from './services';

const syncService = new AgentSyncService(pool);
const configService = new AutoConfigGenerationService(pool);
const learningService = new SelfLearningOrchestrationService(pool);
```

## Agent Synchronization

### Two-Way Communication

Create channels for bidirectional agent communication:

```typescript
// Create sync channel
const channel = await syncService.createSyncChannel({
  name: 'seo-agents',
  channel_type: 'bidirectional',
  sync_strategy: 'immediate'
});

// Subscribe agent
await syncService.subscribeAgentToChannel(agentId, channel.channel_id);

// Agent publishes state (agent → system)
await syncService.publishSyncEvent(channel.channel_id, {
  source_agent_id: agentId,
  event_type: 'status_update',
  data: { status: 'processing', progress: 0.5 }
});

// System broadcasts to agents (system → agents)
await syncService.broadcastToChannel(channel.channel_id, {
  event_type: 'config_update',
  data: { new_config: {...} }
});
```

### State Management

Track and reconcile agent states:

```typescript
// Create state snapshot
const snapshot = await syncService.createStateSnapshot(agentId, {
  current_task: 'seo_analysis',
  progress: 75,
  metrics: { processed: 1500, remaining: 500 }
});

// Get current state
const currentState = await syncService.getCurrentState(agentId);

// Reconcile conflicts
const reconciledState = await syncService.reconcileStates(
  agentId,
  'merge',  // strategy: merge | latest_wins | manual
  conflictData
);
```

### Simulation Result Propagation

Automatically sync simulation results to agents:

```typescript
await syncService.propagateSimulationResults(
  simulationId,
  { estimated_duration: 5000, predicted_output: {...} },
  [agentId1, agentId2]  // target agents
);
```

## Auto-Configuration Generation

### Generate from Patterns

Create optimal configurations from historical patterns:

```typescript
// Generate config
const config = await configService.generateConfigFromPatterns(
  'seo_workflow',
  {
    min_success_rate: 0.85,
    max_cost: 50,
    preferred_patterns: [patternId1, patternId2]
  }
);

// Config is generated by merging successful patterns
console.log(config.generated_config);
// { parallelism: 5, cache_enabled: true, timeout: 30000, ... }
```

### Test Configurations

Validate configs through simulation:

```typescript
const testResult = await configService.testGeneratedConfig(
  config.config_id,
  { input: 'test data' }
);

console.log(testResult.success);  // true/false
console.log(testResult.performance_metrics);
// { execution_time: 4500, cost: 0.25, accuracy: 0.92, ... }
```

### Iterative Improvement

Automatically improve configurations:

```typescript
const improved = await configService.improveConfig(
  config.config_id,
  {
    target_metric: 'execution_time',
    improvement_goal: 0.20,  // 20% faster
    max_iterations: 5
  }
);

// Returns optimized configuration
```

### Get Best Configuration

Find the best-performing configuration:

```typescript
const best = await configService.getBestConfiguration(
  'seo_workflow',
  {
    metric: 'cost_effectiveness',
    min_tests: 5
  }
);
```

## Self-Learning Orchestration

### DeepSeek-Managed Learning

Start learning sessions for agents:

```typescript
const session = await learningService.startLearningSession(agentId, {
  focus_area: 'task_orchestration',
  learning_budget: {
    time_ms: 60000,  // 1 minute
    cost_usd: 1.0    // $1 budget
  }
});
```

### Research Campaigns

Launch data mining campaigns:

```typescript
const campaign = await learningService.launchResearchCampaign({
  topic: 'workflow_optimization',
  data_sources: ['execution_history', 'simulation_results', 'security_checks'],
  mining_depth: 3
});

// Wait for completion, then mine patterns
const patterns = await learningService.minePatterns(campaign.campaign_id);

console.log(patterns);
// [
//   { pattern_category: 'high_success_workflow', confidence_score: 0.95, ... },
//   { pattern_category: 'cost_efficient_workflow', confidence_score: 0.85, ... }
// ]
```

### Pattern-Based Optimization

Generate and apply optimizations:

```typescript
// Generate optimization from pattern
const optimization = await learningService.generateOptimization(
  pattern.pattern_id,
  { target: 'execution_efficiency' }
);

// Test it
const testResult = await learningService.testOptimization(
  optimization.optimization_id
);

// Apply if beneficial
if (testResult.cost_benefit_ratio > 2.0) {
  await learningService.applyOptimization(optimization.optimization_id);
}
```

### Track Improvements

Monitor self-learning progress:

```typescript
const metrics = await learningService.getOptimizationMetrics(agentId);

console.log(metrics);
// {
//   total_optimizations: 15,
//   total_improvement: 0.45,  // 45% improvement
//   total_cost_savings: 125.50,
//   avg_performance_improvement: 0.30  // 30% average
// }
```

## Complete Workflow Example

```typescript
// 1. Setup sync channel
const channel = await syncService.createSyncChannel({
  name: 'learning-workflow',
  channel_type: 'bidirectional',
  sync_strategy: 'immediate'
});

await syncService.subscribeAgentToChannel(agentId, channel.channel_id);

// 2. Start learning session
const session = await learningService.startLearningSession(agentId, {
  focus_area: 'seo_optimization'
});

// 3. Launch research campaign
const campaign = await learningService.launchResearchCampaign({
  topic: 'seo_best_practices',
  data_sources: ['execution_history', 'simulation_results']
});

// 4. Mine patterns
const patterns = await learningService.minePatterns(campaign.campaign_id);

// 5. Generate config from patterns
const config = await configService.generateConfigFromPatterns(
  'seo_workflow',
  { min_success_rate: 0.8 }
);

// 6. Test config
const testResult = await configService.testGeneratedConfig(
  config.config_id,
  { url: 'https://example.com' }
);

// 7. Broadcast to agents if successful
if (testResult.success) {
  await syncService.broadcastToChannel(channel.channel_id, {
    event_type: 'new_config_available',
    data: { config_id: config.config_id, test_results: testResult }
  });
}

// 8. Generate optimizations
for (const pattern of patterns.slice(0, 3)) {
  const opt = await learningService.generateOptimization(pattern.pattern_id);
  const result = await learningService.testOptimization(opt.optimization_id);
  
  if (result.cost_benefit_ratio > 2.0) {
    await learningService.applyOptimization(opt.optimization_id);
    
    // Sync to agents
    await syncService.broadcastToChannel(channel.channel_id, {
      event_type: 'optimization_applied',
      data: { optimization_id: opt.optimization_id, improvement: result.actual_improvement }
    });
  }
}

// 9. Track overall progress
const metrics = await learningService.getOptimizationMetrics(agentId);
console.log(`Total improvements: ${metrics.total_optimizations}`);
console.log(`Performance gain: ${metrics.avg_performance_improvement * 100}%`);
console.log(`Cost savings: $${metrics.total_cost_savings}`);
```

## API Endpoints

### Synchronization

- `POST /api/agent-sync/channels` - Create sync channel
- `GET /api/agent-sync/channels/:id` - Get channel
- `POST /api/agent-sync/channels/:id/subscribe` - Subscribe agent
- `POST /api/agent-sync/channels/:id/publish` - Publish event
- `POST /api/agent-sync/channels/:id/broadcast` - Broadcast to all
- `GET /api/agent-sync/agents/:id/events` - Get agent events
- `GET /api/agent-sync/agents/:id/state` - Get current state
- `POST /api/agent-sync/agents/:id/snapshot` - Create snapshot
- `POST /api/agent-sync/agents/:id/reconcile` - Reconcile conflicts
- `GET /api/agent-sync/statistics` - Get sync statistics

### Auto-Configuration

- `POST /api/agent-sync/configs/generate` - Generate config
- `POST /api/agent-sync/configs/:id/test` - Test config
- `POST /api/agent-sync/configs/:id/improve` - Improve config
- `GET /api/agent-sync/configs/best` - Get best config
- `GET /api/agent-sync/configs/statistics` - Get statistics

### Self-Learning

- `POST /api/agent-sync/learning/sessions` - Start session
- `POST /api/agent-sync/learning/sessions/:id/end` - End session
- `POST /api/agent-sync/learning/research` - Launch campaign
- `GET /api/agent-sync/learning/research/:id` - Get campaign
- `POST /api/agent-sync/learning/patterns/mine` - Mine patterns
- `GET /api/agent-sync/learning/patterns/:id` - Get pattern
- `POST /api/agent-sync/learning/optimize` - Generate optimization
- `POST /api/agent-sync/learning/optimizations/:id/test` - Test
- `POST /api/agent-sync/learning/optimizations/:id/apply` - Apply
- `GET /api/agent-sync/learning/metrics/:agent_id` - Get metrics
- `GET /api/agent-sync/learning/statistics` - Get statistics

## Database Tables

### Agent Synchronization (4 tables)
- `agent_sync_channels` - Communication channels
- `agent_channel_subscriptions` - Agent subscriptions
- `agent_sync_events` - Published events
- `agent_state_snapshots` - State versions

### Auto-Configuration (2 tables)
- `auto_generated_configs` - Generated configurations
- `config_test_results` - Test outcomes

### Self-Learning (4 tables)
- `learning_sessions` - Learning sessions
- `research_campaigns` - Research campaigns
- `learning_patterns` - Discovered patterns (10 seeded)
- `optimizations` - Generated optimizations
- `optimization_metrics` - Performance tracking

## Best Practices

1. **Always Test First**: Never apply configs or optimizations without testing
2. **Use Simulation**: Validate changes through simulation before deployment
3. **Monitor Metrics**: Track improvement metrics to measure ROI
4. **Set Budgets**: Limit learning costs with time/cost budgets
5. **Prefer Patterns**: Use pattern-based generation over manual config
6. **Sync Frequently**: Keep agents in sync with latest data
7. **Reconcile Conflicts**: Use appropriate strategy for state conflicts
8. **Track Snapshots**: Create snapshots before major changes

## Troubleshooting

### Sync Not Working

Check channel subscription:
```typescript
const stats = await syncService.getSyncStatistics(channelId);
console.log(stats); // Shows subscriber count
```

### Config Generation Fails

Ensure patterns exist:
```sql
SELECT * FROM learning_patterns 
WHERE pattern_category = 'your_workflow_type'
AND confidence_score >= 0.7;
```

### Learning Not Improving

Check research campaign results:
```typescript
const campaign = await learningService.getResearchCampaign(campaignId);
console.log(campaign.findings); // Shows discovered patterns
```

## Performance Tips

- Use `batched` sync strategy for high-volume events
- Set appropriate mining depth (1-3) for campaigns
- Limit pattern count in config generation
- Use cost budgets to prevent runaway learning
- Archive old snapshots to reduce database size

## Next Steps

- Integrate with workflow execution engine
- Add WebSocket support for real-time sync
- Implement ML models for better predictions
- Add visualization dashboard
- Create pattern marketplace

## Support

For issues or questions:
- Check logs in `agent_sync_events` table
- Review pattern confidence scores
- Examine test results in `config_test_results`
- Monitor optimization metrics

---

**System Status**: Production Ready
**Version**: 1.0.0
**Last Updated**: 2025-11-04
